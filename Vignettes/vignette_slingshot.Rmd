
# Slingshot vignette

https://bioconductor.org/packages/devel/bioc/vignettes/slingshot/inst/doc/vignette.html

# Introduction

- full single-cell lineage analysis workflow
- emphasis on lineage reconstruction, pseudotime inference

`slingshot` goal
- use cell clusters to uncover global structure
- convert structure into smooth lineages represented by 1-dim variables called "pseudotime"

min `slingshot` input
- mtx of cells in reduced-dim space
- vector of cluster labels

overview
- two inputs
- ID global lineage structure by constructing MST on clusters (`getLineages`)
- construct smooth lineages + infer pseudotime vars by fitting simultaneous principal curves w/ `getCurves` function
assess output of each step w/ built-in viz tools

## Datasets

- two simulated datasets

DS1
- single trajectory/lineage
- 1/3 of genes associated w/ transition
```{r load DS1}
library(SingleCellExperiment)

# generate synthetic count data representing a single lineage
means <- rbind(
    # non-DE genes
    matrix(rep(rep(c(0.1,0.5,1,2,3), each = 300),100),
        ncol = 300, byrow = TRUE),
    # early deactivation
    matrix(rep(exp(atan( ((300:1)-200)/50 )),50), ncol = 300, byrow = TRUE),
    # late deactivation
    matrix(rep(exp(atan( ((300:1)-100)/50 )),50), ncol = 300, byrow = TRUE),
    # early activation
    matrix(rep(exp(atan( ((1:300)-100)/50 )),50), ncol = 300, byrow = TRUE),
    # late activation
    matrix(rep(exp(atan( ((1:300)-200)/50 )),50), ncol = 300, byrow = TRUE),
    # transient
    matrix(rep(exp(atan( c((1:100)/33, rep(3,100), (100:1)/33) )),50), 
        ncol = 300, byrow = TRUE)
)
counts <- apply(means,2,function(cell_means){
    total <- rnbinom(1, mu = 7500, size = 4)
    rmultinom(1, total, cell_means)
})
rownames(counts) <- paste0('G',1:750)
colnames(counts) <- paste0('c',1:300)
sce <- SingleCellExperiment(assays = List(counts = counts))
```

DS2: bifurcating trajectory
- mtx of coordinates (like reduced dim)
- cluster labels generated by k-means clustering

```{r Load DS2}
# BiocManager::install("slingshot")
library(slingshot, quietly = FALSE)
data("slingshotExample")
rd <- slingshotExample$rd
cl <- slingshotExample$cl

dim(rd) # data representing cells in a reduced dimensional space
length(cl) # vector of cluster labels
```

# Upstream analysis

## Gene filtering
- reduce dim of data + filter out uninformative genes as first step
  - improve speed of downstream analysis, minimize info loss

filter
- retain genes robustly expressed in enough cells to constitute a cluster
  - potentially interesting cell-type marker genes
- min cluster: 10 cells
- "robustly expressed" gene: simulated count of at least 3 reads

```{r gene filter}
# filter genes down to potential cell-type markers
# at least M (15) reads in at least N (15) cells
geneFilter <- apply(assays(sce)$counts,1,function(x){
    sum(x >= 3) >= 10
})
sce <- sce[geneFilter, ]
```

## Normalization

- remove unwanted technical / biological artifacts from data
  - batch, seq depth, cell cycle effects, etc.
- `scone`: can compare variety of normalization techniques according to diff evaluation criteria
- ZINB-WaVE: dim red while accounting for technical variables
- MNN: correct for batch effects after dim reduction

simulated data -> no batch effects / confounders
- use full quantile normalization: forces each cell to have same distribution of expression values

```{r FQnorm}
FQnorm <- function(counts){
    rk <- apply(counts,2,rank,ties.method='min')
    counts.sort <- apply(counts,2,sort)
    refdist <- apply(counts.sort,1,median)
    norm <- apply(rk,2,function(r){ refdist[r] })
    rownames(norm) <- rownames(counts)
    return(norm)
}
assays(sce)$norm <- FQnorm(assays(sce)$counts)
```

## Dimensionality reduction

`slingshot` assumption: transcriptionally similar cells will be close to each other in reduced-dimensional space
- low-dim representation of data important in using Euclidean distances to construct lineages and measure pseudotime
- many dimensional reduction methods
  - ex. PCA, UMAP

PCA: do not scale genes by variance b/c not all genes are equally informative
- want to find signal in robustly expressed, highly variable genes
- don't dampen signal by forcing equal variance across genes

```{r PCA, fig.width=6, fig.height=6}
pca <- prcomp(t(log1p(assays(sce)$norm)), scale. = FALSE)
rd1 <- pca$x[,1:2]

plot(rd1, col = rgb(0,0,0,.5), pch=16, asp = 1)
```

```{r UMAP w/ uwot, fig.width=6, fig.height=6}
library(uwot)
rd2 <- uwot::umap(t(log1p(assays(sce)$norm)))
colnames(rd2) <- c('UMAP1', 'UMAP2')

plot(rd2, col = rgb(0,0,0,.5), pch=16, asp = 1)
```

```{r Add reduced dims to SCE obj}
reducedDims(sce) <- SimpleList(PCA = rd1, UMAP = rd2)
```

## Clustering cells

- `slingshot` input: vector of cluster labels for the cells
- if not provided, data treated as single cluster, fit std principal curve
- recommend clustering cells even if only single lineage expected -> potential discovery of novel branching events
- clusters used to determine global structure of underlying lineages
  - their number, when branch off, approx. location of branching event
  - diff from typical single-cell clustering to ID biologically relevant cell types in dataset

ex. clustering: Gaussian mixture modeling + k-means
- assume Euclidean distance in low-dim space reflect biological diffs btwn cells
- GMM: `mclust` pkg, automated method for determining # of clusters based on Bayesian information criterion (BIC)

```{r GMM clustering, fig.width=6, fig.height=6}
# install.packages("mclust")
library(mclust, quietly = TRUE)

cl1 <- Mclust(rd1)$classification
colData(sce)$GMM <- cl1

library(RColorBrewer)
plot(rd1, col = brewer.pal(9,"Set1")[cl1], pch=16, asp = 1)
```

# Use Slingshot

two step process
- `getLineages`: ID global lineage structure w/ cluster-based MST
- `getCurves`: fit simultaneous principal curves to describe each lineage

`slingshot`: wrapper function
- both steps of trajectory inference at once
- inputs: reduced dim mtx of coords + set of cluster labels
  - either separate objs or elements within `SingleCellExperiment` obj
  - if no clustering results: assume all cells in 1 cluster, single curve constructed
  - if no dimred provided, `slingshot` uses 1st element of list returned by `reducedDims`

ex. `slingshot` w/ PCA dimred + GMM cluster labels
```{r slingshot wrapper}
sce <- slingshot(sce, clusterLabels = 'GMM', reducedDim = 'PCA')
```

output: `SingleCellExperiment` obj w/ `slingshot` results incorporated
  - results stored in `PseudotimeOrdering` obj added to `colData` of original obj
    - `colData(sce)$slingshot` to access
  - inferred pseudotime vars (1 per lineage) added to `colData` individually

to extract all `slingshot` results as object
- `as.PseudotimeOrdering`: extension of `SummarizedExperiment` objs, flexible + useful for most purposes
- `as.SlingshotDataSet`: primarily used for using `slingshot` package plotting methods

```{r viz inferred single trajectory lineage, fig.width=6, fig.height=6}
summary(sce$slingPseudotime_1)

library(grDevices)
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(sce$slingPseudotime_1, breaks=100)]

plot(reducedDims(sce)$PCA, col = plotcol, pch=16, asp = 1)
lines(SlingshotDataSet(sce), lwd=2, col='black')
```

```{r original lineage by cluster-based MST estimation, fig.width=6, fig.height=6}
plot(reducedDims(sce)$PCA, col = brewer.pal(9,'Set1')[sce$GMM], pch=16, asp = 1)
lines(SlingshotDataSet(sce), lwd=2, type = 'lineages', col = 'black')
```

# Downstream analysis

## Temporally dynamic genes

`tradeSeq` pkg analysis
- for each gene, fit general additive model (GAM) w/ negative binomial noise distribution
- model (potentially nonlinear) relationships btwn gene exp + pseudotime
- test for significant associations btwn expression + pseudotime w/ `associationTest`

```{r tradeSeq}
# BiocManager::install("tradeSeq")
library(tradeSeq)
sce <- fitGAM(sce) # fit negative binomial GAM
ATres <- associationTest(sce) # test for dynamic expression
```

- pick top genes based on p-values
- visualize expression over developmental time w/ heatmap
```{r heatmap top 250 dynamically expressed genes, fig.width=10, fig.height=10}
topgenes <- rownames(ATres[order(ATres$pvalue), ])[1:250]
pst.ord <- order(sce$slingPseudotime_1, na.last = NA)
heatdata <- assays(sce)$counts[topgenes, pst.ord]
heatclus <- sce$GMM[pst.ord]

heatmap(log1p(heatdata), Colv = NA,
        ColSideColors = brewer.pal(9,"Set1")[heatclus])
```

# Detailed Slingshot functionality

`slingshotExample` dataset
- represent cells in low dim space
- set of cluster labels by k-means clustering
- use as objs directly instead of `SingleCellExperiment` obj

## ID global lineage structure

`getLineages` function
- input: `n` x `p` mtx, vector of clustering results of length `n`
- map connection btwn adjacent clusters w/ minimum spanning tree (MST)
- ID path through connections taht represent lineages
- output: `PseudotimeOrdering` object w/ inputs as well as inferred MST (`igraph` obj) + lineages (ordered vectors of cluster names)

unsupervised / semi-supervised analysis
- can specify known initial + terminal pt clusters
- if no start specified, selected based on parsimony
  - maximize # of clusters shared btwn lineages before split
  - if no splits or multiple clusters w/ same parsimony score, starting cluster chosen arbitrarily

ex. simulated data: Cluster 1 selected as start cluster
- generally recommend specify initial cluster based on prior knowledge
- no effect on MST construction, but impact on how branching cruves are constructed

```{r getLineages}
lin1 <- getLineages(rd, cl, start.clus = '1')
lin1
```
```{r plot lineage, fig.width=6, fig.height=6}
plot(rd, col = brewer.pal(9,"Set1")[cl], asp = 1, pch = 16)
lines(SlingshotDataSet(lin1), lwd = 3, col = 'black')
```

specifying known endpoints
- terminal cell state clusters constrained to have only one connection (must be leaf nodes) when MST is constructed
- can impact how other parts of tree are drawn
```{r specify Cl3 as endpoint, fig.width=6, fig.height=6}
lin2 <- getLineages(rd, cl, start.clus= '1', end.clus = '3')
plot(rd, col = brewer.pal(9,"Set1")[cl], asp = 1, pch = 16)
lines(SlingshotDataSet(lin2), lwd = 3, col = 'black', show.constraints = TRUE)
```

supervision useful for ensuring results consistent w/ prior biological knowledge
- prevent known terminal cell fates from being transitory

`getLineages` add'l args
- `dist.method`: specify how distances btwn cluster should be computed
  - `slingshot` default: use dist btwn cluster centers, normalized by full, join covariance mtx
    - if small clusters (fewer cells than dimensionality of data), switch to using diagonal joint covariance mtx
  - options: `simple` (Euclidean), `scaled.full`, `scaled.diag`, `mnn` (mutual nearest neighbor-based dist)
- `omega`: granularity parameter, set upper limit on connection distances
  - represent distance btwn every real cluster and an artificial `.OMEGA` cluster removed after fitting MST
  - useful for identifying outlier clusters not part of lineage or for separating distinct trajectories
  - numeric arg or logical value: `TRUE` indicates heuristic of 1.5 x (median edge length of unsupervised MST) should be used
  - maximum allowable distance will be 3x that distance

`PseudotimeOrdering` output
- holds all inputs
- list of lineages
- add'l info on how they were constructed
- used as input to `getCurves` function

## Constructing smooth curves, ordering cells

`getCurves` function
- construct smooth curves to model development along lineages
- smooth curves based on all cells -> eliminate problem of cells projecting only vertices of piece-wise linear trajectories
  - robust to noise in clustering results
  - smoothness: iterative process similar to principal curves (Hastie and Stuetzle 1989)
    - single lineage = principal curve through center of data w/ adjustment: initial curve constructed w/ linear connections btwn cluster centers rather than 1st principal component of data
      - stability, faster convergence
    - 2+ lineages: averaging curves near shared cells
      - both lineages should agree well on cells yet to differentiate
      - increase stability of algo, produce smooth branching lineages

```{r getCurves}
crv1 <- getCurves(lin1)
crv1
```
```{r plot curves, fig.width=6, fig.height=6}
plot(rd, col = brewer.pal(9,"Set1")[cl], asp = 1, pch = 16)
lines(SlingshotDataSet(crv1), lwd = 3, col = 'black')
```

`getCurves` output: updated `PseudotimeOrdering`
- contains simultaneous principal curves + add'l info on how they were fit
- `slingPseudotime` function: extract cells-by-lineages mtx of pseudotime values for each cell along each lineage
  - `NA` for cells not assigned to lineage
- `slingCurveWeights` function: extract mtx of weights assigning each cell to one or more lineages

`slingCurves` function: access curves object, return list of `principal_curve` objs w/ slots:
- `s`: mtx of pts that make up curve; corresponds to orthogonal projection of data pts
- `ord`: indices that can be used to put cells along curve in order based on projs
- `lambda`: arclengths along curve from beginning to each cell's projection; mtx of values returned by `slingPseudotime` fx
- `dist_ind`: squared dists btwn data pts + projections onto curve
- `dist`: sum of squared projection distances
- `w`: vector of weights along lineage
  - `w = 1`: unambiguous assignment of cell to lineage
    - can have multiple 1 or close to 1 if cell close to branching event
  - `w = 0`: cells assigned to other lineage
  - mtx of values returned by `slingCurveWeights` fx

## Slingshot on large datasets

use `approx_points` arg w/ `slingshot` or `getCurves`
- computationally expensive to iteratively project all pts into 1+ curves
- specify resolution of curves (# of unique pts)
- default `approx_points`: either 150 or # of cells in dataset, whichever is smaller
- `approx_points = FALSE`: maximally "dense" curves, w/ as many points as there are cells in the dataset
  - projection step in iterative curve-fitting w/ $n^2$ computational complexity
- restricting # of unique pts along curve != limiting # of unique pseudotime values

```{r ex. low approx_points, fig.width=6, fig.height=6}
sce5 <- slingshot(
  sce, clusterLabels = 'GMM',
  reducedDim = 'PCA', approx_points = 5)

colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(sce5$slingPseudotime_1, breaks=100)]

plot(reducedDims(sce5)$PCA, col = plotcol, pch=16, asp = 1)
lines(SlingshotDataSet(sce5), lwd=2, col='black')
```

## Multiple trajectories

aka disjoint trajectories
- `omega` artificial cluster
- `omega = TRUE`: implement rule of thumb where max allowable edge length = 3x median edge length of MST constructed w/o artificial cluster
  - same as saying default value for `omega_scale` is 1.5

```{r Multiple trajs fit cluster MST, fig.width=6, fig.height=6}
rd2 <- rbind(rd, cbind(rd[,2]-12, rd[,1]-6))
cl2 <- c(cl, cl + 10)
pto2 <- slingshot(rd2, cl2, omega = TRUE, start.clus = c(1,11))

plot(rd2, pch=16, asp = 1,
     col = c(brewer.pal(9,"Set1"), brewer.pal(8,"Set2"))[cl2])
lines(SlingshotDataSet(pto2), type = 'l', lwd=2, col='black')
```

```{r Multiple trajs fit princurves, fig.width=6, fig.height=6}
plot(rd2, pch=16, asp = 1,
     col = c(brewer.pal(9,"Set1"), brewer.pal(8,"Set2"))[cl2])
lines(SlingshotDataSet(pto2), lwd=2, col='black')
```

## Project cells onto existing trajectories

`predict` function
```{r projection to traj}
pto <- sce$slingshot # our original PseudotimeOrdering
newPCA <- reducedDim(sce, 'PCA') +
  rnorm(2*ncol(sce), sd = 2) # simulate new cells in PCA space
newPTO <- slingshot::predict(pto, newPCA) # project onto trajectory
```

yields new hybrid obj w/ trajectories / curves from original data, but pseudotime vals + weights for new cells

```{r proj to traj plot, fig.width=6, fig.height=6}
newplotcol <- colors[cut(slingPseudotime(newPTO)[,1], breaks=100)]
plot(reducedDims(sce)$PCA, col = 'grey', bg = 'grey', pch=21, asp = 1,
     xlim = range(newPCA[,1]), ylim = range(newPCA[,2]))
lines(SlingshotDataSet(sce), lwd=2, col = 'black')
points(slingReducedDim(newPTO), col = newplotcol, pch = 16)
```

